//------------------------------------------------------------------------------
//  mc6847.cc
//------------------------------------------------------------------------------
#include "mc6847.h"

namespace YAKC {

// 8 color palette
// FIXME: these are pure colors currently, fix
// those according to the YUV values from the 6847
static const uint32_t colors[8] = {
    0xFF00FF00, // green
    0xFF00FFFF, // yellow
    0xFFFF0000, // blue
    0xFF0000FF, // red
    0xFFFFFFFF, // buff
    0xFFFFFF00, // cyan
    0xFFFF00FF, // magenta
    0xFF0077FF, // orange
};

// internal character ROM dump from MAME
// (ntsc_square_fontdata8x12 in devices/video/mc6847.cpp)
static const uint8_t fontdata8x12[64 * 12] =
{
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x1A, 0x2A, 0x2A, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x12, 0x12, 0x1C, 0x12, 0x12, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x12, 0x12, 0x12, 0x12, 0x12, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x20, 0x20, 0x38, 0x20, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x20, 0x20, 0x38, 0x20, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1E, 0x20, 0x20, 0x26, 0x22, 0x22, 0x1E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x36, 0x2A, 0x2A, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x32, 0x2A, 0x26, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x2A, 0x24, 0x1A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x28, 0x24, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x10, 0x08, 0x04, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x2A, 0x2A, 0x36, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x3E, 0x10, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x14, 0x36, 0x00, 0x36, 0x14, 0x14, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x1E, 0x20, 0x1C, 0x02, 0x3C, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x32, 0x32, 0x04, 0x08, 0x10, 0x26, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x28, 0x28, 0x10, 0x2A, 0x24, 0x1A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x1C, 0x3E, 0x1C, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x10, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x24, 0x24, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x1C, 0x20, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x04, 0x02, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x0C, 0x14, 0x3E, 0x04, 0x04, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x20, 0x3C, 0x02, 0x02, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x1C, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x24, 0x04, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00,
};

//------------------------------------------------------------------------------
void
mc6847::init(read_func reader_func, uint32_t* fb_write_ptr, int cpu_khz) {
    // the 6847 is clocked at 3.58 MHz, the CPU clock is lower, thus
    // need to compute tick counter limit in CPU ticks
    const int vdg_khz = 3580;

    // one scanline is 228 3.58 MHz ticks, increase fixed point precision
    h_limit = (228 * cpu_khz * prec) / vdg_khz;
    h_sync_start = (10 * cpu_khz * prec) / vdg_khz;
    h_sync_end = (26 * cpu_khz * prec) / vdg_khz;
    h_count = 0;
    l_count = 0;
    bits = 0;
    read_addr_func = reader_func;
    rgba8_buffer = fb_write_ptr;
}

//------------------------------------------------------------------------------
void
mc6847::reset() {
    h_count = 0;
    l_count = 0;
    bits = 0;
}

//------------------------------------------------------------------------------
void
mc6847::step() {
    prev_bits = bits;
    h_count += prec;
    if ((h_count >= h_sync_start) && (h_count < h_sync_end)) {
        // HSYNC on
        bits |= HSYNC;
        if (l_count == l_disp_end) {
            // switch FSYNC on
            bits |= FSYNC;
        }
    }
    else {
        // HSYNC off
        bits &= ~HSYNC;
    }
    if (h_count >= h_limit) {
        h_count -= h_limit;
        l_count++;
        if (l_count >= l_limit) {
            // rewind line counter, FSYNC off
            l_count = 0;
            bits &= ~FSYNC;
        }
        if ((l_count >= l_disp_start) && (l_count < l_disp_end)) {
            decode_line(l_count - l_disp_start);
        }
    }
}

//------------------------------------------------------------------------------
void
mc6847::decode_line(int y) {
    uint32_t* dst = &(this->rgba8_buffer[y * disp_width]);
    if (bits & A_G) {
        // one of the 8 graphics modes
        if (bits & GM0) {
            // one of the 'resolution modes' (1 bit == 1 pixel)
            
        }
        else {
            // one of the 'color modes' (2 bits == 4 colors, CSS select
            // lower or upper half of palette)

        }
        // FIXME!
        uint8_t r = (y & 7) << 5;
        for (int x = 0; x < disp_width; x++) {
            uint8_t g = (x & 7) << 5;
            *dst++ = 0xFF000000 | (g<<8) | r;
        }
    }
    else {
        // we're in alphanumeric/semigraphics mode, one cell
        // is 8x12 pixels, bit 6 is connected to A_S+INT_EXT and
        // may select semigraphics mode per-characters, bit
        // 7 is connected to INV and may invert the character
        // (this is ignored in semigraphics mode)

        // the vidmem src address and offset into the font data
        uint16_t addr = (y/12)*32;
        uint8_t m;  // the pixel bitmask
        const int chr_y = y % 12;
        // bit-shifters to extract a 2x2 or 2x3 semigraphics 2-bit stack
        const int shift_2x2 = (1 - (chr_y / 6))*2;
        const int shift_2x3 = (2 - (chr_y / 4))*2;
        const uint32_t alnum_fg = (bits & CSS) ? alnum_amber : alnum_green;
        const uint32_t alnum_bg = (bits & CSS) ? alnum_dark_amber : alnum_dark_green;
        for (int x = 0; x < 32; x++) {
            const uint8_t chr = this->read_addr_func(addr++);
            if (bits & A_S) {
                // semigraphics mode
                uint32_t fg_color;
                if (bits & INT_EXT) {
                    // 2x3 semigraphics, 2 color sets at 4 colors (selected by CSS pin)
                    // |C1|C0|L5|L4|L3|L2|L1|L0|
                    //
                    // +--+--+
                    // |L5|L4|
                    // +--+--+
                    // |L3|L2|
                    // +--+--+
                    // |L1|L0|
                    // +--+--+

                    // extract the 2 horizontal bits from one of the 3 stacks
                    m = (chr>>shift_2x3) & 3;
                    // 2 bits of color, CSS bit selects upper or lower
                    // half of color palette
                    fg_color = colors[((chr>>6)&3) + ((bits&CSS)?4:0)];
                }
                else {
                    // 2x2 semigraphics, 8 colors + black
                    // |xx|C2|C1|C0|L3|L2|L1|L0|
                    //
                    // +--+--+
                    // |L3|L2|
                    // +--+--+
                    // |L1|L0|
                    // +--+--+

                    // extract the 2 horizontal bits from the upper or lower stack
                    m = (chr>>shift_2x2) & 3;
                    // 3 color bits directly point into the color palette
                    fg_color = colors[(chr>>4) & 7];
                }
                // write the horizontal pixel blocks (2 blocks @ 4 pixel each)
                for (int p = 1; p>=0; p--) {
                    uint32_t c = (m & (1<<p)) ? fg_color : 0xFF000000;
                    *dst++=c; *dst++=c; *dst++=c; *dst++=c;
                }
            }
            else {
                // alphanumeric mode
                // FIXME: INT_EXT (switch between internal and
                // external font
                uint8_t m = fontdata8x12[(chr&0x3F)*12 + chr_y];
                if (bits & INV) {
                    m = ~m;
                }
                for (int p = 7; p >= 0; p--) {
                    *dst++ = m & (1<<p) ? alnum_fg : alnum_bg;
                }
            }
        }
    }
}

} // namespace YAKC
