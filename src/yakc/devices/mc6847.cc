//------------------------------------------------------------------------------
//  mc6847.cc
//------------------------------------------------------------------------------
#include "mc6847.h"

namespace YAKC {

// 8 color palette
// FIXME: these are pure colors currently, fix
// those according to the YUV values from the 6847
static const uint32_t colors[8] = {
    0xFF00FF00, // green
    0xFF00FFFF, // yellow
    0xFFFF0000, // blue
    0xFF0000FF, // red
    0xFFFFFFFF, // buff
    0xFF00FF77, // cyan
    0xFFFF00FF, // magenta
    0xFF0077FF, // orange
};

// internal character ROM dump from MAME
// (ntsc_square_fontdata8x12 in devices/video/mc6847.cpp)
static const uint8_t fontdata8x12[64 * 12] =
{
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x1A, 0x2A, 0x2A, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x12, 0x12, 0x1C, 0x12, 0x12, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x12, 0x12, 0x12, 0x12, 0x12, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x20, 0x20, 0x38, 0x20, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x20, 0x20, 0x38, 0x20, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1E, 0x20, 0x20, 0x26, 0x22, 0x22, 0x1E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x36, 0x2A, 0x2A, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x32, 0x2A, 0x26, 0x22, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x2A, 0x24, 0x1A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x28, 0x24, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x10, 0x08, 0x04, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x2A, 0x2A, 0x36, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x20, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x3E, 0x10, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x14, 0x14, 0x36, 0x00, 0x36, 0x14, 0x14, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x1E, 0x20, 0x1C, 0x02, 0x3C, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x32, 0x32, 0x04, 0x08, 0x10, 0x26, 0x26, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x28, 0x28, 0x10, 0x2A, 0x24, 0x1A, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x1C, 0x3E, 0x1C, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x10, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x24, 0x24, 0x24, 0x24, 0x24, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x1C, 0x20, 0x20, 0x3E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x02, 0x04, 0x02, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x0C, 0x14, 0x3E, 0x04, 0x04, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x20, 0x3C, 0x02, 0x02, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x1C, 0x22, 0x22, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x1C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x24, 0x04, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00,
};

//------------------------------------------------------------------------------
void
mc6847::init(read_func reader_func, uint32_t* fb_write_ptr, int cpu_khz) {
    // the 6847 is clocked at 3.58 MHz, the CPU clock is lower, thus
    // need to compute tick counter limit in CPU ticks
    const int vdg_khz = 3580;

    // one scanline is 228 3.58 MHz ticks, increase fixed point precision
    h_limit = (228 * cpu_khz * prec) / vdg_khz;
    h_sync_start = (10 * cpu_khz * prec) / vdg_khz;
    h_sync_end = (26 * cpu_khz * prec) / vdg_khz;
    h_count = 0;
    l_count = 0;
    bits = 0;
    read_addr_func = reader_func;
    rgba8_buffer = fb_write_ptr;
}

//------------------------------------------------------------------------------
void
mc6847::reset() {
    h_count = 0;
    l_count = 0;
    bits = 0;
}

//------------------------------------------------------------------------------
void
mc6847::step() {
    prev_bits = bits;
    h_count += prec;
    if ((h_count >= h_sync_start) && (h_count < h_sync_end)) {
        // HSYNC on
        bits |= HSYNC;
        if (l_count == l_disp_end) {
            // switch FSYNC on
            bits |= FSYNC;
        }
    }
    else {
        // HSYNC off
        bits &= ~HSYNC;
    }
    if (h_count >= h_limit) {
        h_count -= h_limit;
        l_count++;
        if (l_count >= l_limit) {
            // rewind line counter, FSYNC off
            l_count = 0;
            bits &= ~FSYNC;
        }
        if ((l_count >= l_disp_start) && (l_count < l_disp_end)) {
            decode_line(l_count - l_disp_start);
        }
    }
}

//------------------------------------------------------------------------------
void
mc6847::decode_line(int y) {
    if (y < disp_height) {
        uint32_t* ptr = &(this->rgba8_buffer[y * disp_width]);
        if (bits & A_G) {
            // one of the 8 graphics modes
            // FIXME!
            uint8_t r = (y & 7) << 5;
            for (int x = 0; x < disp_width; x++) {
                uint8_t g = (x & 7) << 5;
                *ptr++ = 0xFF000000 | (g<<8) | r;
            }
        }
        else {
            // an alphanumeric/semigraphics mode
            decode_line_alnum(ptr, y);
        }
    }
}

//------------------------------------------------------------------------------
void
mc6847::decode_line_alnum(uint32_t* dst, int y) {
    // we're in alphanumeric mode, one character cell is
    // 8x12 pixels, the character bitmaps in the internal
    // ROM are 5x7 pixels, offsetted 2 pixels horizontally
    // and 3 pixels vertically
    //
    // NOTE that the video memory bytes may toogle
    // the alphanumeric/semigraphics mode, inverse and
    // other status flags!

    // the vidmem src address and offset into the font data
    uint16_t addr = (y/12)*32;
    uint32_t fg, bg;
    const int chr_y   = y % 12;
    // bit-shifters to extract a 2x2 or 2x3 semigraphics 2-bit stack
    const int shift_2x2 = (1 - (chr_y / 6))*2;
    const int shift_2x3 = (2 - (chr_y / 4))*2;
    for (int x = 0; x < 32; x++) {
        const uint8_t chr = this->read_addr_func(addr++);
        if (bits & A_S) {
            // background in semigraphics is always black
            bg = 0xFF000000;
            // semigraphics mode
            if (bits & INT_EXT) {
                // 2x3 semigraphics, 2 color sets at 4 colors (selected by CSS)
                // |C1|C0|L5|L4|L3|L2|L1|L0|
                //
                // +--+--+
                // |L5|L4|
                // +--+--+
                // |L3|L2|
                // +--+--+
                // |L1|L0|
                // +--+--+

                // extract the 2 horizontal bits from one of the 3 stacks
                uint8_t l = (chr>>shift_2x3) & 3;
                // 2 bits of color, CSS bit selects upper or lower
                // half of color palette
                fg = colors[((chr>>6)&3) + ((bits&CSS)?4:0)];
                for (int p = 1; p>=0; p--) {
                    if (l & (1<<p)) {
                        *dst++=fg; *dst++=fg; *dst++=fg; *dst++=fg;
                    }
                    else {
                        *dst++=bg; *dst++=bg; *dst++=bg; *dst++=bg;
                    }
                }
            }
            else {
                // 2x2 semigraphics, 8 colors + black
                // |xx|C2|C1|C0|L3|L2|L1|L0|
                //
                // +--+--+
                // |L3|L2|
                // +--+--+
                // |L1|L0|
                // +--+--+

                // extract the 2 horizontal bits from the upper or lower stack
                uint8_t l = (chr>>shift_2x2) & 3;
                fg = colors[(chr>>4) & 7];
                for (int p = 1; p>=0; p--) {
                    if (l & (1<<p)) {
                        *dst++=fg; *dst++=fg; *dst++=fg; *dst++=fg;
                    }
                    else {
                        *dst++=bg; *dst++=bg; *dst++=bg; *dst++=bg;
                    }
                }
            }
        }
        else {
            // alphanumeric mode
            // FIXME: INT_EXT (switch between internal and
            // external font
            uint8_t m = fontdata8x12[(chr&0x3F)*12 + chr_y];
            if (bits & INV) {
                m = ~m;
            }
            if (bits & CSS) {
                fg = alnum_amber;
                bg = alnum_dark_amber;
            }
            else {
                fg = alnum_green;
                bg = alnum_dark_green;
            }
            for (int p = 7; p >= 0; p--) {
                *dst++ = m & (1<<p) ? fg : bg;
            }
        }
    }
}

} // namespace YAKC
